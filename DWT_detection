"""This module implements the Discrete Wavelet Transform (DWT) detection from the
paper by Raave (2024). The purpose is to retrieve the bit stream from the watermarked
data and see whether this matches the original bit stream of the owner"""

import numpy as np
import pywt
import DWT_parameters as DWT
from ECG_robust import ecg_signal, SignalAnalysis
from DWT_implementation import DWT_watermarked_data

imaginary_indices = np.where(np.iscomplex(DWT_watermarked_data))
gap_starts = np.where(np.diff(imaginary_indices) > 1)[0] + 1
# print(gap_starts)
start_indices = np.insert(imaginary_indices[gap_starts], 0, imaginary_indices[0])
print(start_indices)
# ok = np.where(np.diff(imaginary_indices) == 2)[1]
# print(ok)

# gap_starts = np.where(np.diff(imaginary_indices) != 1)[1]# + 1
# print(gap_starts)
# start_indices = np.insert(imaginary_indices[gap_starts], 0, imaginary_indices[0])

# start_indices = imaginary_indices[np.insert(np.diff(imaginary_indices) > 1, 0, True)]
# print(start_indices)

# step 1: find the barker codes (imaginary #, so easy to spot)
# beginning of barker code = beginning of section (so now we can split the sections)
# split to sections, then split sections to n1 and n2 (unsure if we have the length of n1 and n2 beforehand, or just assume)
# apply DWT to each n2 and divide the approx coeffs to f frames

# So for each coefficient c in a frame, the nth number is found in ref that is closest to the magnitude
# of c. Each n connected to each c is stored. If the values of n are more often odd than even per frame, the
# watermark bit is a 1 and if it is the other way around, it is a 0. Therefore the algorithm always uses odd-sized
# frames to prevent ambiguity. Once all frames have been considered, the watermark has been extracted from the
# sequence.
