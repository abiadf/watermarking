"""This module implements the Discrete Wavelet Transform (DWT) detection from the
paper by Raave (2024). The purpose is to retrieve the bit stream from the watermarked
data and see whether this matches the original bit stream of the owner"""

import numpy as np
import pywt
import DWT_parameters as DWT
from ECG_robust import ecg_signal, SignalAnalysis
from DWT_implementation import dwt_watermarked_data, get_wavelet_approx_coeffs

def find_barker_code_start(dwt_watermarked_data: np.ndarray) -> np.ndarray:
    """Identifies the starting indices of the Barker code [1 1 1 0 1] embedded in the 
    imaginary components of the input data
    1. Find indices of complex values (where Barker code is embedded)
    2. Compute the difference between consecutive indices
    3. Locate positions where the difference is `2` (indicating the position of `0` in Barker code)
    4. Adjust indices to get the starting position of the Barker sequence (the 0 is 3 indices after start)
    Args:
        DWT_watermarked_data (np.ndarray): dataset containing embedded Barker code in its imaginary space
    Returns:
        np.ndarray: Indices of where the Barker code starts"""

    # Constants based on Barker code pattern [1 1 1 0 1]
    OFFSET_AFTER_DIFF  = 1  # np.diff offsets by 1, so we shift back
    GAP_BETWEEN_1S     = 2  # Distance between indices when encountering the '0' in the Barker code
    BARKER_START_SHIFT = 3 # The 0 is the 4th element in Barker code, so start is 3 places before

    complex_indices        = np.where(np.iscomplex(dwt_watermarked_data))[0] #gets indices of complex values
    index_diffs            = np.diff(complex_indices) # compute index differences
    zero_positions         = np.where(index_diffs == GAP_BETWEEN_1S)[0] # Find where 0 is in the sequence
    idx_of_zeros           = complex_indices[zero_positions] + OFFSET_AFTER_DIFF # gets actual idx of 0s
    barker_code_starts_idx = idx_of_zeros - BARKER_START_SHIFT # compute start indices
    return barker_code_starts_idx

def _get_n1_n2_start_end_indices(dwt_watermarked_data, n1_start_indices):
    """Computes the start and end indices for n1 and n2 regions
    - Sections are of varying length, but within a section, n1 and n2 are equal
    Args:
        dwt_watermarked_data (np.ndarray): full dataset
        n1_start_indices (np.ndarray): Indices where n1 starts for each section
    Returns:
        tuple: (n1_end_indices, n2_start_indices, n2_end_indices"""

    section_lengths  = np.diff(n1_start_indices, append=len(dwt_watermarked_data))  
    n1_lengths       = section_lengths // 2  

    n2_start_indices = n1_start_indices + n1_lengths  
    n1_end_indices   = n2_start_indices - 1  # Last index of n1
    n2_end_indices   = n2_start_indices + n1_lengths - 1  # Last index of n2

    return n1_end_indices, n2_start_indices, n2_end_indices

def split_dataset_into_n1_n2(dataset, n1_start_indices):
    """Splits the dataset into sections, each containing n1 and n2 subarrays
    Args:
        dataset (np.ndarray): The full dataset
        n1_start_indices (np.ndarray): Indices where n1 starts for each section
    Returns:
        list: A list of sections, where each section is [n1_array, n2_array]"""
    # Get section indices
    n1_end_indices, n2_start_indices, n2_end_indices = _get_n1_n2_start_end_indices(dataset, n1_start_indices)

    dataset_with_split_sections = [
        [dataset[n1_start:n1_end + 1], dataset[n2_start:n2_end + 1]] 
        for n1_start, n1_end, n2_start, n2_end in zip(n1_start_indices, n1_end_indices, n2_start_indices, n2_end_indices)]
    return dataset_with_split_sections

barker_code_starts_idx = find_barker_code_start(dwt_watermarked_data)

n1_start_indices = barker_code_starts_idx
dataset_with_split_sections = split_dataset_into_n1_n2(dwt_watermarked_data, n1_start_indices)

for i, section in enumerate(dataset_with_split_sections):
    for j, subsection in enumerate(section):
        if j % 2 != 0: #n2
            c_approx, c_detail = get_wavelet_approx_coeffs(subsection, DWT.wavelet_type, DWT.LEVEL_1)


# step 1: find the barker codes (imaginary #, so easy to spot)
# beginning of barker code = beginning of section (so now we can split the sections)
# split to sections, then split sections to n1 and n2 (unsure if we have the length of n1 and n2 beforehand, or just assume)
# apply DWT to each n2 and divide the approx coeffs to f frames

# So for each coefficient c in a frame, the nth number is found in ref that is closest to the magnitude
# of c. Each n connected to each c is stored. If the values of n are more often odd than even per frame, the
# watermark bit is a 1 and if it is the other way around, it is a 0. Therefore the algorithm always uses odd-sized
# frames to prevent ambiguity. Once all frames have been considered, the watermark has been extracted from the
# sequence.
